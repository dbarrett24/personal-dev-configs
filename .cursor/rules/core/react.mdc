---
description: React component patterns and best practices for functional components
globs:
  - "**/*.tsx"
  - "**/components/**/*.ts"
alwaysApply: true
---
# React Component Patterns

## Component Structure

### Functional Components Only

- **Use functional components exclusively** - no class components
- **React imports may or may not be needed** - depends on JSX transform configuration (see below)
- **Named exports only** (except for page.tsx files in Next.js)

## React Import Requirements

### Current Project Status
**IMPORTANT**: Check your project's JSX transform configuration before assuming imports are/aren't needed.

### When React Imports Are Required
- Using `"jsx": "react"` (classic transform) in `tsconfig.json`
- Test framework uses Babel without new JSX transform configured
- Configuration mismatch between TypeScript and test tooling

### When React Imports Are NOT Required  
- Using `"jsx": "react-jsx"` or `"jsx": "react-jsxdev"` in `tsconfig.json`
- Test framework properly configured for new JSX transform:
  - `@swc/jest` with appropriate config
  - Vitest with `@vitejs/plugin-react-swc`
  - Babel with `{ "runtime": "automatic" }`
- All tooling aligned on new transform

### How to Validate Your Project

**Step 1: Check TypeScript Config**
```bash
# Look for "jsx" setting in tsconfig.json
grep -r "jsx" tsconfig*.json
```

**Step 2: Check Test Config**
```bash
# Check what transform your tests use
grep -r "transform" jest.config.* vitest.config.*
```

**Step 3: Identify Mismatches**
```
❌ MISMATCH (React imports REQUIRED):
TypeScript: "jsx": "react-jsx"
Jest:       babel-jest (default config)

✅ ALIGNED (No React imports needed):
TypeScript: "jsx": "react-jsx"  
Jest:       @swc/jest or Vitest with SWC
```

### If You Find a Mismatch
1. **Document it as technical debt** in project notes
2. **Add React imports** to all component files as a temporary workaround
3. **Propose migration** to aligned tooling (e.g., Jest + @swc/jest)
4. **Don't silently ignore** - this causes confusing errors during development

```typescript
// ✅ CORRECT - Functional component with proper structure
export const MyComponent = ({ title, isActive = false }: MyComponentProps) => {
    // Component logic here
    return <div>{title}</div>;
};

// ❌ AVOID - Class component
class MyComponent extends React.Component {
    // Don't use class components
}
```

## Props and Types

### Component Props Pattern

```typescript
// Define props as a type, not interface
type MyComponentProps = {
    title: string;
    isActive?: boolean;
    onAction?: (id: string) => void;
    children?: React.ReactNode;
};

// Use props directly in function signature
export const MyComponent = ({ title, isActive = false, onAction, children }: MyComponentProps) => {
    // Component implementation
};
```

### Display Names

Always add display names to components for better debugging:

```typescript
MyComponent.displayName = 'MyComponent';
```

## Hooks and State

### Hook Usage Patterns

- Place hooks at the top of the component
- Group related hooks together
- Custom hooks should start with 'use'

```typescript
export const MyComponent = ({ data }: MyComponentProps) => {
    // State hooks
    const [isOpen, setIsOpen] = useState(false);
    const [selectedItem, setSelectedItem] = useState<string | null>(null);

    // Data hooks (React Query)
    const { data: items, isLoading } = useGetItems();

    // State hooks (Jotai)
    const [userState, setUserState] = useAtom(userAtom);

    // Effect hooks
    useEffect(() => {
        // Effect logic
    }, [dependency]);

    // Component logic and render
};
```

## Component Patterns

### Conditional Rendering

```typescript
// ✅ PREFERRED - Early returns for clarity
export const MyComponent = ({ isEnabled }: MyComponentProps) => {
    if (!isEnabled) {
        return null;
    }

    return <div>Component content</div>;
};

// ✅ ALSO GOOD - Ternary for simple conditions
return isLoading ? <Spinner /> : <Content data={data} />;

// ✅ GOOD - Logical AND for existence checks
return data && <DataDisplay data={data} />;
```

### Children and Composition

```typescript
type ContainerProps = {
    title: string;
    children: React.ReactNode;
};

export const Container = ({ title, children }: ContainerProps) => {
    return (
        <div className="container">
            <h2>{title}</h2>
            {children}
        </div>
    );
};
```

## Performance Patterns

### Memoization

Use sparingly and only when performance issues are identified:

```typescript
// Only memoize expensive computations
const expensiveValue = useMemo(() => {
    return computeExpensiveValue(data);
}, [data]);

// Only memoize callbacks passed to many children
const handleClick = useCallback(
    (id: string) => {
        // Handle click
    },
    [dependency]
);
```

## Code Style

### Arrow Functions

Always use arrow functions for component definitions and methods:

```typescript
// ✅ CORRECT
export const Button = ({ onClick, children }: ButtonProps) => {
    return <button onClick={onClick}>{children}</button>;
};

// ❌ AVOID
export function Button({ onClick, children }: ButtonProps) {
    return <button onClick={onClick}>{children}</button>;
}
```

### Event Handlers

```typescript
// ✅ CORRECT - Clear naming
const handleClick = (event: React.MouseEvent) => {
    // Handle click
};

const handleSubmit = (data: FormData) => {
    // Handle submit
};

// Pass to props with 'on' prefix
<Button onClick={handleClick} onSubmit={handleSubmit} />
```