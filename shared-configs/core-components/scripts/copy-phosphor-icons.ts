import { promises as fs } from 'fs';
import { phosphorIcons } from '../src/Icons/importedIcons';
import path from 'path';

const PHOSPHOR_BASE = path.resolve(__dirname, '../node_modules/@phosphor-icons/react/dist/ssr');
const INDEX_PATH = path.resolve(__dirname, '../src/Icons');
const OUTPUT_PATH = path.resolve(__dirname, '../src/Icons/generatedIcons');

async function copyPhosphorIcons() {
    await fs.mkdir(OUTPUT_PATH, { recursive: true });

    // Create an array to store all successful icon names
    const successfulIcons: string[] = [];

    for (const iconName of phosphorIcons) {
        try {
            const phosphorName = iconName === 'Close' ? 'X' : iconName;

            // Read from the .d.ts file in the ssr directory
            const defContent = await fs.readFile(path.join(PHOSPHOR_BASE, `${phosphorName}.d.ts`), 'utf8');

            const weights = extractWeights(defContent);

            const componentContent = `\
// Code generated by copy-phosphor-icons.ts. DO NOT EDIT.
import * as React from 'react';
import { IconBase, IconProps } from '../IconBase';

const weights = ${weights};

export const ${iconName} = React.forwardRef<SVGSVGElement, IconProps>((props, ref) => {
    return <IconBase ref={ref} displayName="${iconName}" {...props} weights={weights} />;
});

${iconName}.displayName = '${iconName}';
`;

            await fs.writeFile(path.join(OUTPUT_PATH, `${iconName}.tsx`), componentContent);
            successfulIcons.push(iconName);
        } catch (error) {
            // eslint-disable-next-line no-console
            console.error(`Failed to process ${iconName}:`, error);
        }
    }

    // Generate index.ts file with exports for all successful icons
    const indexContent =
        successfulIcons.map((iconName) => `export * from './generatedIcons/${iconName}';`).join('\n') + '\n';

    await fs.writeFile(path.join(INDEX_PATH, 'index.ts'), indexContent);

    // eslint-disable-next-line no-console
    console.log(`âœ… Generated ${successfulIcons.length} icon components`);
}

function extractWeights(content: string): string {
    const weights: Record<string, string> = {};
    const weightTypes = ['regular', 'bold', 'fill', 'duotone'];

    weightTypes.forEach((weight) => {
        const regex = new RegExp(`@${weight} !\\[img\\]\\(data:image\\/svg\\+xml;base64,([^)]+)\\)`);
        const match = content.match(regex);

        if (match?.[1]) {
            const svgContent = Buffer.from(match[1], 'base64').toString('utf-8');

            if (weight === 'duotone') {
                // For duotone, look for both paths
                const pathMatches = svgContent.match(/<path[^>]*d="([^"]+)"[^>]*>/g);
                if (pathMatches && pathMatches.length >= 2) {
                    const backgroundMatch = pathMatches[0].match(/d="([^"]+)"/);
                    const foregroundMatch = pathMatches[1].match(/d="([^"]+)"/);

                    if (backgroundMatch && foregroundMatch) {
                        const backgroundPath = backgroundMatch[1];
                        const foregroundPath = foregroundMatch[1];

                        weights[weight] =
                            `React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 256 256", fill: "currentColor" },
    React.createElement("path", { d: "${backgroundPath}", opacity: "0.2" }),
    React.createElement("path", { d: "${foregroundPath}" })
)`;
                    }
                }
            } else {
                const pathMatch = svgContent.match(/<path\s+d="([^"]+)"/);
                if (pathMatch?.[1]) {
                    weights[weight] =
                        `React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 256 256", fill: "currentColor" },
    React.createElement("path", { d: "${pathMatch[1]}" })
)`;
                }
            }
        }
    });

    return `{\n  ${Object.entries(weights)
        .map(([weight, svgPath]) => `${weight}: ${svgPath}`)
        .join(',\n  ')}\n}`;
}

// eslint-disable-next-line no-console
copyPhosphorIcons().catch(console.error);
